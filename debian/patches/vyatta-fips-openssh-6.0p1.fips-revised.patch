From: Jan Blunck <jblunck@vyatta.com>
Subject: openssh-6.0p1.fips-revised.patch

This is a port of the OpenSSH upstream patch originally located here:
http://www.openssl.com/export/openssh/openssh-6.0p1.fips-revised.patch
--- a/cipher.c
+++ b/cipher.c
@@ -54,10 +54,9 @@
 extern const EVP_CIPHER *evp_ssh1_bf(void);
 extern const EVP_CIPHER *evp_ssh1_3des(void);
 extern void ssh1_3des_iv(EVP_CIPHER_CTX *, int, u_char *, int);
-extern const EVP_CIPHER *evp_aes_128_ctr(void);
 extern void ssh_aes_ctr_iv(EVP_CIPHER_CTX *, int, u_char *, u_int);
 
-struct Cipher {
+static struct Cipher {
 	char	*name;
 	int	number;		/* for ssh1 only */
 	u_int	block_size;
@@ -82,15 +81,52 @@
 	{ "aes256-cbc",		SSH_CIPHER_SSH2, 16, 32, 0, 1, EVP_aes_256_cbc },
 	{ "rijndael-cbc@lysator.liu.se",
 				SSH_CIPHER_SSH2, 16, 32, 0, 1, EVP_aes_256_cbc },
-	{ "aes128-ctr",		SSH_CIPHER_SSH2, 16, 16, 0, 0, evp_aes_128_ctr },
-	{ "aes192-ctr",		SSH_CIPHER_SSH2, 16, 24, 0, 0, evp_aes_128_ctr },
-	{ "aes256-ctr",		SSH_CIPHER_SSH2, 16, 32, 0, 0, evp_aes_128_ctr },
+	{ "aes128-ctr",		SSH_CIPHER_SSH2, 16, 16, 0, 0, EVP_aes_128_ctr },
+	{ "aes192-ctr",		SSH_CIPHER_SSH2, 16, 24, 0, 0, EVP_aes_192_ctr },
+	{ "aes256-ctr",		SSH_CIPHER_SSH2, 16, 32, 0, 0, EVP_aes_256_ctr },
 #ifdef USE_CIPHER_ACSS
 	{ "acss@openssh.org",	SSH_CIPHER_SSH2, 16, 5, 0, 0, EVP_acss },
 #endif
 	{ NULL,			SSH_CIPHER_INVALID, 0, 0, 0, 0, NULL }
 };
 
+#ifdef OPENSSL_FIPS_CAPABLE
+/* subset of the ciphers table above which is relevant for FIPS140 usage */
+static struct Cipher fips_ciphers[] = {
+	/*
+	 * Having the cipher "none" in this list is required by
+	 * packet.c:packet_set_connection() function. This cipher is not
+	 * useable for encryption since it is not of type SSH_CIPHER_SSH2
+	 * (which is tested in ciphers_valid() function below).
+	 */
+	{ "none",		SSH_CIPHER_NONE, 8, 0, 0, 0, EVP_enc_null },
+	{ "3des-cbc",		SSH_CIPHER_SSH2, 8, 24, 0, 1, EVP_des_ede3_cbc },
+	{ "aes128-cbc",		SSH_CIPHER_SSH2, 16, 16, 0, 1, EVP_aes_128_cbc },
+	{ "aes192-cbc",		SSH_CIPHER_SSH2, 16, 24, 0, 1, EVP_aes_192_cbc },
+	{ "aes256-cbc",		SSH_CIPHER_SSH2, 16, 32, 0, 1, EVP_aes_256_cbc },
+	{ "rijndael-cbc@lysator.liu.se",
+				SSH_CIPHER_SSH2, 16, 32, 0, 1, EVP_aes_256_cbc },
+	{ "aes128-ctr",		SSH_CIPHER_SSH2, 16, 16, 0, 0, EVP_aes_128_ctr },
+	{ "aes192-ctr",		SSH_CIPHER_SSH2, 16, 24, 0, 0, EVP_aes_192_ctr },
+	{ "aes256-ctr",		SSH_CIPHER_SSH2, 16, 32, 0, 0, EVP_aes_256_ctr },
+	{ NULL,			SSH_CIPHER_INVALID, 0, 0, 0, 0, NULL }
+};
+#endif /* OPENSSL_FIPS_CAPABLE */
+
+/* return the correct list of ciphers depending on what mode we are
+ * operating in (non-FIPS140 or FIPS140 mode)
+ */
+struct Cipher *ciphers_list(void)
+{
+#ifdef OPENSSL_FIPS_CAPABLE
+  if (FIPS_mode())
+    return fips_ciphers;
+  else
+#endif /* OPENSSL_FIPS_CAPABLE */
+    return ciphers;
+}
+
+
 /*--*/
 
 u_int
@@ -133,7 +169,7 @@
 cipher_by_name(const char *name)
 {
 	Cipher *c;
-	for (c = ciphers; c->name != NULL; c++)
+	for (c = ciphers_list(); c->name != NULL; c++)
 		if (strcmp(c->name, name) == 0)
 			return c;
 	return NULL;
@@ -143,7 +179,7 @@
 cipher_by_number(int id)
 {
 	Cipher *c;
-	for (c = ciphers; c->name != NULL; c++)
+	for (c = ciphers_list(); c->name != NULL; c++)
 		if (c->number == id)
 			return c;
 	return NULL;
@@ -187,7 +223,7 @@
 	Cipher *c;
 	if (name == NULL)
 		return -1;
-	for (c = ciphers; c->name != NULL; c++)
+	for (c = ciphers_list(); c->name != NULL; c++)
 		if (strcasecmp(c->name, name) == 0)
 			return c->number;
 	return -1;
@@ -294,21 +330,19 @@
  * passphrase and using the resulting 16 bytes as the key.
  */
 
-void
+int
 cipher_set_key_string(CipherContext *cc, Cipher *cipher,
     const char *passphrase, int do_encrypt)
 {
-	MD5_CTX md;
 	u_char digest[16];
 
-	MD5_Init(&md);
-	MD5_Update(&md, (const u_char *)passphrase, strlen(passphrase));
-	MD5_Final(digest, &md);
+	if (EVP_Digest(passphrase, strlen(passphrase), digest, NULL, EVP_md5(), NULL) <= 0)
+	  return -1;
 
 	cipher_init(cc, cipher, digest, 16, NULL, 0, do_encrypt);
 
 	memset(digest, 0, sizeof(digest));
-	memset(&md, 0, sizeof(md));
+	return 0;
 }
 
 /*
@@ -351,10 +385,7 @@
 			ssh_rijndael_iv(&cc->evp, 0, iv, len);
 		else
 #endif
-		if (c->evptype == evp_aes_128_ctr)
-			ssh_aes_ctr_iv(&cc->evp, 0, iv, len);
-		else
-			memcpy(iv, cc->evp.iv, len);
+		memcpy(iv, cc->evp.iv, len);
 		break;
 	case SSH_CIPHER_3DES:
 		ssh1_3des_iv(&cc->evp, 0, iv, 24);
@@ -382,10 +413,7 @@
 			ssh_rijndael_iv(&cc->evp, 1, iv, evplen);
 		else
 #endif
-		if (c->evptype == evp_aes_128_ctr)
-			ssh_aes_ctr_iv(&cc->evp, 1, iv, evplen);
-		else
-			memcpy(cc->evp.iv, iv, evplen);
+		memcpy(cc->evp.iv, iv, evplen);
 		break;
 	case SSH_CIPHER_3DES:
 		ssh1_3des_iv(&cc->evp, 1, iv, 24);
@@ -409,7 +437,12 @@
 	Cipher *c = cc->cipher;
 	int plen = 0;
 
+#ifdef OPENSSL_FIPS_CAPABLE
+	if ((FIPS_mode() && (c->evptype == EVP_acss)) ||
+		(c->evptype == EVP_rc4 || c->evptype == EVP_acss)) {
+#else
 	if (c->evptype == EVP_rc4 || c->evptype == EVP_acss) {
+#endif
 		plen = EVP_X_STATE_LEN(cc->evp);
 		if (dat == NULL)
 			return (plen);
@@ -424,7 +457,12 @@
 	Cipher *c = cc->cipher;
 	int plen;
 
+#ifdef OPENSSL_FIPS_CAPABLE
+	if ((FIPS_mode() && (c->evptype == EVP_acss)) ||
+		(c->evptype == EVP_rc4 || c->evptype == EVP_acss)) {
+#else
 	if (c->evptype == EVP_rc4 || c->evptype == EVP_acss) {
+#endif
 		plen = EVP_X_STATE_LEN(cc->evp);
 		memcpy(EVP_X_STATE(cc->evp), dat, plen);
 	}
--- a/cipher-ctr.c
+++ /dev/null
@@ -1,146 +0,0 @@
-/* $OpenBSD: cipher-ctr.c,v 1.11 2010/10/01 23:05:32 djm Exp $ */
-/*
- * Copyright (c) 2003 Markus Friedl <markus@openbsd.org>
- *
- * Permission to use, copy, modify, and distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-#include "includes.h"
-
-#include <sys/types.h>
-
-#include <stdarg.h>
-#include <string.h>
-
-#include <openssl/evp.h>
-
-#include "xmalloc.h"
-#include "log.h"
-
-/* compatibility with old or broken OpenSSL versions */
-#include "openbsd-compat/openssl-compat.h"
-
-#ifndef USE_BUILTIN_RIJNDAEL
-#include <openssl/aes.h>
-#endif
-
-const EVP_CIPHER *evp_aes_128_ctr(void);
-void ssh_aes_ctr_iv(EVP_CIPHER_CTX *, int, u_char *, size_t);
-
-struct ssh_aes_ctr_ctx
-{
-	AES_KEY		aes_ctx;
-	u_char		aes_counter[AES_BLOCK_SIZE];
-};
-
-/*
- * increment counter 'ctr',
- * the counter is of size 'len' bytes and stored in network-byte-order.
- * (LSB at ctr[len-1], MSB at ctr[0])
- */
-static void
-ssh_ctr_inc(u_char *ctr, size_t len)
-{
-	int i;
-
-	for (i = len - 1; i >= 0; i--)
-		if (++ctr[i])	/* continue on overflow */
-			return;
-}
-
-static int
-ssh_aes_ctr(EVP_CIPHER_CTX *ctx, u_char *dest, const u_char *src,
-    LIBCRYPTO_EVP_INL_TYPE len)
-{
-	struct ssh_aes_ctr_ctx *c;
-	size_t n = 0;
-	u_char buf[AES_BLOCK_SIZE];
-
-	if (len == 0)
-		return (1);
-	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) == NULL)
-		return (0);
-
-	while ((len--) > 0) {
-		if (n == 0) {
-			AES_encrypt(c->aes_counter, buf, &c->aes_ctx);
-			ssh_ctr_inc(c->aes_counter, AES_BLOCK_SIZE);
-		}
-		*(dest++) = *(src++) ^ buf[n];
-		n = (n + 1) % AES_BLOCK_SIZE;
-	}
-	return (1);
-}
-
-static int
-ssh_aes_ctr_init(EVP_CIPHER_CTX *ctx, const u_char *key, const u_char *iv,
-    int enc)
-{
-	struct ssh_aes_ctr_ctx *c;
-
-	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) == NULL) {
-		c = xmalloc(sizeof(*c));
-		EVP_CIPHER_CTX_set_app_data(ctx, c);
-	}
-	if (key != NULL)
-		AES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
-		    &c->aes_ctx);
-	if (iv != NULL)
-		memcpy(c->aes_counter, iv, AES_BLOCK_SIZE);
-	return (1);
-}
-
-static int
-ssh_aes_ctr_cleanup(EVP_CIPHER_CTX *ctx)
-{
-	struct ssh_aes_ctr_ctx *c;
-
-	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) != NULL) {
-		memset(c, 0, sizeof(*c));
-		xfree(c);
-		EVP_CIPHER_CTX_set_app_data(ctx, NULL);
-	}
-	return (1);
-}
-
-void
-ssh_aes_ctr_iv(EVP_CIPHER_CTX *evp, int doset, u_char * iv, size_t len)
-{
-	struct ssh_aes_ctr_ctx *c;
-
-	if ((c = EVP_CIPHER_CTX_get_app_data(evp)) == NULL)
-		fatal("ssh_aes_ctr_iv: no context");
-	if (doset)
-		memcpy(c->aes_counter, iv, len);
-	else
-		memcpy(iv, c->aes_counter, len);
-}
-
-const EVP_CIPHER *
-evp_aes_128_ctr(void)
-{
-	static EVP_CIPHER aes_ctr;
-
-	memset(&aes_ctr, 0, sizeof(EVP_CIPHER));
-	aes_ctr.nid = NID_undef;
-	aes_ctr.block_size = AES_BLOCK_SIZE;
-	aes_ctr.iv_len = AES_BLOCK_SIZE;
-	aes_ctr.key_len = 16;
-	aes_ctr.init = ssh_aes_ctr_init;
-	aes_ctr.cleanup = ssh_aes_ctr_cleanup;
-	aes_ctr.do_cipher = ssh_aes_ctr;
-#ifndef SSH_OLD_EVP
-	aes_ctr.flags = EVP_CIPH_CBC_MODE | EVP_CIPH_VARIABLE_LENGTH |
-	    EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CUSTOM_IV;
-#endif
-	return (&aes_ctr);
-}
--- a/cipher.h
+++ b/cipher.h
@@ -78,7 +78,7 @@
     const u_char *, u_int, int);
 void	 cipher_crypt(CipherContext *, u_char *, const u_char *, u_int);
 void	 cipher_cleanup(CipherContext *);
-void	 cipher_set_key_string(CipherContext *, Cipher *, const char *, int);
+int	 cipher_set_key_string(CipherContext *, Cipher *, const char *, int);
 u_int	 cipher_blocksize(const Cipher *);
 u_int	 cipher_keylen(const Cipher *);
 u_int	 cipher_is_cbc(const Cipher *);
--- a/configure.ac
+++ b/configure.ac
@@ -2107,6 +2107,42 @@
 	]
 )
 LIBS="-lcrypto $LIBS"
+AC_ARG_WITH(fips-dir,
+	[  --with-fips-dir=PATH     Specify path to OpenSSL FIPS installation ],
+	[
+		if test "x$withval" != "xno" ; then
+			case "$withval" in
+				# Relative paths
+				./*|../*)	withval="`pwd`/$withval"
+			esac
+#			if test -d "$withval/lib"; then
+#				if test -n "${need_dash_r}"; then
+#					LDFLAGS="-L${withval}/lib -R${withval}/lib ${LDFLAGS}"
+#				else
+#					LDFLAGS="-L${withval}/lib -Wl,-R${withval} ${LDFLAGS}"
+#				fi
+#			else
+#				if test -n "${need_dash_r}"; then
+#					LDFLAGS="-L${withval} -R${withval} ${LDFLAGS}"
+#				else
+#					LDFLAGS="-L${withval} -Wl,-R${withval} ${LDFLAGS}"
+#				fi
+#			fi
+#			if test -d "$withval/include"; then
+#				CPPFLAGS="-DOPENSSL_FIPS_CAPABLE -I${withval}/include ${CPPFLAGS}"
+#			else
+#				CPPFLAGS="-DOPENSSL_FIPS_CAPABLE -I${withval} ${CPPFLAGS}"
+#			fi
+			if test -d "$withval"; then
+				CPPFLAGS="-DOPENSSL_FIPS_CAPABLE ${CPPFLAGS}"
+				AC_DEFINE(OPENSSL_FIPS_CAPABLE, 1, [FIPS capable] )
+				fips="yes"
+			fi
+		fi
+		openssl_check_nonfatal=1
+	]
+)
+LIBS="-lcrypto $LIBS"
 AC_TRY_LINK_FUNC([RAND_add], [AC_DEFINE([HAVE_OPENSSL], [1],
 	[Define if your ssl headers are included
 	with #include <openssl/header.h>])],
@@ -4321,6 +4357,7 @@
 H=`eval echo ${PRIVSEP_PATH}` ; H=`eval echo ${H}`
 I=`eval echo ${user_path}` ; I=`eval echo ${I}`
 J=`eval echo ${superuser_path}` ; J=`eval echo ${J}`
+K=`eval echo ${fips}` ; J=`eval echo ${K}`
 
 echo ""
 echo "OpenSSH has been configured with the following options:"
@@ -4377,6 +4414,8 @@
 echo "          +for ssh: ${SSHLIBS}"
 fi
 
+echo "                      fips support: $K"
+
 echo ""
 
 if test "x$MAKE_PACKAGE_SUPPORTED" = "xyes" ; then
--- a/mac.c
+++ b/mac.c
@@ -49,14 +49,14 @@
 #define SSH_EVP		1	/* OpenSSL EVP-based MAC */
 #define SSH_UMAC	2	/* UMAC (not integrated with OpenSSL) */
 
-struct {
+static struct Macs {
 	char		*name;
 	int		type;
 	const EVP_MD *	(*mdfunc)(void);
 	int		truncatebits;	/* truncate digest if != 0 */
 	int		key_len;	/* just for UMAC */
 	int		len;		/* just for UMAC */
-} macs[] = {
+} all_macs[] = {
 	{ "hmac-sha1",			SSH_EVP, EVP_sha1, 0, -1, -1 },
 	{ "hmac-sha1-96",		SSH_EVP, EVP_sha1, 96, -1, -1 },
 #ifdef HAVE_EVP_SHA256
@@ -73,10 +73,39 @@
 	{ NULL,				0, NULL, 0, -1, -1 }
 };
 
+#ifdef OPENSSL_FIPS_CAPABLE
+static struct Macs fips_macs[] = {
+	{ "hmac-sha1",			SSH_EVP, EVP_sha1, 0, -1, -1 },
+	{ "hmac-sha1-96",		SSH_EVP, EVP_sha1, 96, -1, -1 },
+#ifdef HAVE_EVP_SHA256
+	{ "hmac-sha2-256",		SSH_EVP, EVP_sha256, 0, -1, -1 },
+	{ "hmac-sha2-256-96",		SSH_EVP, EVP_sha256, 96, -1, -1 },
+	{ "hmac-sha2-512",		SSH_EVP, EVP_sha512, 0, -1, -1 },
+	{ "hmac-sha2-512-96",		SSH_EVP, EVP_sha512, 96, -1, -1 },
+#endif
+	{ NULL,				0, NULL, 0, -1, -1 }
+};
+#endif /* OPENSSL_FIPS_CAPABLE */
+
+/* return the correct list of ciphers depending on what mode we are
+ * operating in (non-FIPS140 or FIPS140 mode)
+ */
+struct Macs *macs_list(void)
+{
+#ifdef OPENSSL_FIPS_CAPABLE
+  if (FIPS_mode())
+    return fips_macs;
+  else
+#endif /* OPENSSL_FIPS_CAPABLE */
+    return all_macs;
+}
+
 static void
 mac_setup_by_id(Mac *mac, int which)
 {
 	int evp_len;
+	struct Macs *macs=macs_list();
+
 	mac->type = macs[which].type;
 	if (mac->type == SSH_EVP) {
 		mac->evp_md = (*macs[which].mdfunc)();
@@ -96,6 +125,7 @@
 mac_setup(Mac *mac, char *name)
 {
 	int i;
+	struct Macs *macs=macs_list();
 
 	for (i = 0; macs[i].name; i++) {
 		if (strcmp(name, macs[i].name) == 0) {
@@ -119,7 +149,11 @@
 		if (mac->evp_md == NULL)
 			return -1;
 		HMAC_CTX_init(&mac->evp_ctx);
-		HMAC_Init(&mac->evp_ctx, mac->key, mac->key_len, mac->evp_md);
+		if (!HMAC_Init(&mac->evp_ctx, mac->key, mac->key_len, mac->evp_md)) {
+			error("mac_init: %s",
+				ERR_error_string(ERR_get_error(), NULL));
+			return -1;
+		}
 		return 0;
 	case SSH_UMAC:
 		mac->umac_ctx = umac_new(mac->key);
--- a/Makefile.in
+++ b/Makefile.in
@@ -63,7 +63,7 @@
 
 LIBSSH_OBJS=acss.o authfd.o authfile.o bufaux.o bufbn.o buffer.o \
 	canohost.o channels.o cipher.o cipher-acss.o cipher-aes.o \
-	cipher-bf1.o cipher-ctr.o cipher-3des1.o cleanup.o \
+	cipher-bf1.o cipher-3des1.o cleanup.o \
 	compat.o compress.o crc32.o deattack.o fatal.o hostfile.o \
 	log.o match.o md-sha256.o moduli.o nchan.o packet.o \
 	readpass.o rsa.o ttymodes.o xmalloc.o addrmatch.o \
--- a/myproposal.h
+++ b/myproposal.h
@@ -97,6 +97,16 @@
 #define	KEX_DEFAULT_COMP	"none,zlib@openssh.com,zlib"
 #define	KEX_DEFAULT_LANG	""
 
+#ifdef OPENSSL_FIPS_CAPABLE
+/* FIPS subset (note: matches cipher.c and mac.c lists) */
+#define	KEX_FIPS_ENCRYPT \
+	"aes128-ctr,aes192-ctr,aes256-ctr," \
+	"aes128-cbc,3des-cbc," \
+	"aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se"
+#define	KEX_FIPS_MAC \
+	"hmac-sha1,hmac-sha1-96"
+#endif /* OPENSSL_FIPS_CAPABLE */
+
 
 static char *myproposal[PROPOSAL_MAX] = {
 	KEX_DEFAULT_KEX,
--- a/openbsd-compat/bsd-arc4random.c
+++ b/openbsd-compat/bsd-arc4random.c
@@ -33,29 +33,25 @@
 /* Size of key to use */
 #define SEED_SIZE 20
 
-/* Number of bytes to reseed after */
-#define REKEY_BYTES	(1 << 24)
-
 static int rc4_ready = 0;
-static RC4_KEY rc4;
 
 unsigned int
 arc4random(void)
 {
 	unsigned int r = 0;
-	static int first_time = 1;
 
-	if (rc4_ready <= 0) {
-		if (first_time)
-			seed_rng();
-		first_time = 0;
+	if (!rc4_ready)
 		arc4random_stir();
-	}
 
-	RC4(&rc4, sizeof(r), (unsigned char *)&r, (unsigned char *)&r);
+	if (RAND_bytes((unsigned char *)&r,sizeof(r)) <= 0) {
+		/* unfortunately there is no simple way to report this
+		 * to the caller for handling so this is done via
+		 * fatal() as per arc4random_stir
+		 */
+		fatal("Could not obtain random bytes (error %ld)",
+			ERR_get_error());
+	}
 
-	rc4_ready -= sizeof(r);
-	
 	return(r);
 }
 
@@ -63,24 +59,12 @@
 arc4random_stir(void)
 {
 	unsigned char rand_buf[SEED_SIZE];
-	int i;
 
-	memset(&rc4, 0, sizeof(rc4));
 	if (RAND_bytes(rand_buf, sizeof(rand_buf)) <= 0)
 		fatal("Couldn't obtain random bytes (error %ld)",
 		    ERR_get_error());
-	RC4_set_key(&rc4, sizeof(rand_buf), rand_buf);
-
-	/*
-	 * Discard early keystream, as per recommendations in:
-	 * http://www.wisdom.weizmann.ac.il/~itsik/RC4/Papers/Rc4_ksa.ps
-	 */
-	for(i = 0; i <= 256; i += sizeof(rand_buf))
-		RC4(&rc4, sizeof(rand_buf), rand_buf, rand_buf);
-
-	memset(rand_buf, 0, sizeof(rand_buf));
 
-	rc4_ready = REKEY_BYTES;
+	rc4_ready = 1;
 }
 #endif /* !HAVE_ARC4RANDOM */
 
--- a/readconf.c
+++ b/readconf.c
@@ -140,6 +140,9 @@
 	oVisualHostKey, oUseRoaming, oZeroKnowledgePasswordAuthentication,
 	oKexAlgorithms, oIPQoS, oRequestTTY,
 	oProtocolKeepAlives, oSetupTimeOut,
+#ifdef OPENSSL_FIPS_CAPABLE
+	oFIPS,
+#endif
 	oDeprecated, oUnsupported
 } OpCodes;
 
@@ -262,6 +265,9 @@
 	{ "requesttty", oRequestTTY },
 	{ "protocolkeepalives", oProtocolKeepAlives },
 	{ "setuptimeout", oSetupTimeOut },
+#ifdef OPENSSL_FIPS_CAPABLE
+	{ "fips", oFIPS },
+#endif
 
 	{ NULL, oBadOption }
 };
@@ -1086,6 +1092,11 @@
 		debug("%s line %d: Deprecated option \"%s\"",
 		    filename, linenum, keyword);
 		return 0;
+#ifdef OPENSSL_FIPS_CAPABLE
+	case oFIPS:
+		intptr = &options->fips_mode;
+		goto parse_flag;
+#endif
 
 	case oUnsupported:
 		error("%s line %d: Unsupported option \"%s\"",
@@ -1245,6 +1256,9 @@
 	options->ip_qos_interactive = -1;
 	options->ip_qos_bulk = -1;
 	options->request_tty = -1;
+#ifdef OPENSSL_FIPS_CAPABLE
+	options->fips_mode = -1;
+#endif
 }
 
 /*
@@ -1420,6 +1434,10 @@
 		options->ip_qos_bulk = IPTOS_THROUGHPUT;
 	if (options->request_tty == -1)
 		options->request_tty = REQUEST_TTY_AUTO;
+#ifdef OPENSSL_FIPS_CAPABLE
+	if (options->fips_mode == -1)
+		options->fips_mode = 0;
+#endif
 	/* options->local_command should not be set by default */
 	/* options->proxy_command should not be set by default */
 	/* options->user will be set in the main program if appropriate */
--- a/readconf.h
+++ b/readconf.h
@@ -140,6 +140,9 @@
 	int	use_roaming;
 
 	int	request_tty;
+#ifdef OPENSSL_FIPS_CAPABLE
+	int	fips_mode;
+#endif
 }       Options;
 
 #define SSHCTL_MASTER_NO	0
--- a/servconf.c
+++ b/servconf.c
@@ -142,6 +142,9 @@
 	options->ip_qos_interactive = -1;
 	options->ip_qos_bulk = -1;
 	options->debian_banner = -1;
+#ifdef OPENSSL_FIPS_CAPABLE
+	options->fips_mode = -1;
+#endif
 }
 
 void
@@ -302,6 +305,10 @@
 		options->compression = 0;
 	}
 #endif
+#ifdef OPENSSL_FIPS_CAPABLE
+	if (options->fips_mode == -1)
+		options->fips_mode = 0;
+#endif
 
 }
 
@@ -339,6 +346,9 @@
 	sRevokedKeys, sTrustedUserCAKeys, sAuthorizedPrincipalsFile,
 	sKexAlgorithms, sIPQoS,
 	sDebianBanner,
+#ifdef OPENSSL_FIPS_CAPABLE
+	sFIPS,
+#endif
 	sDeprecated, sUnsupported
 } ServerOpCodes;
 
@@ -474,6 +484,9 @@
 	{ "kexalgorithms", sKexAlgorithms, SSHCFG_GLOBAL },
 	{ "ipqos", sIPQoS, SSHCFG_ALL },
 	{ "debianbanner", sDebianBanner, SSHCFG_GLOBAL },
+#ifdef OPENSSL_FIPS_CAPABLE
+	{ "FIPS", sFIPS, SSHCFG_ALL },
+#endif
 	{ NULL, sBadOption, 0 }
 };
 
@@ -1443,6 +1456,11 @@
 		while (arg)
 		    arg = strdelim(&cp);
 		break;
+#ifdef OPENSSL_FIPS_CAPABLE
+	case sFIPS:
+		intptr = &options->fips_mode;
+		goto parse_flag;
+#endif
 
 	case sUnsupported:
 		logit("%s line %d: Unsupported option %s",
@@ -1838,6 +1856,9 @@
 
 	printf("ipqos %s ", iptos2str(o->ip_qos_interactive));
 	printf("%s\n", iptos2str(o->ip_qos_bulk));
+#ifdef OPENSSL_FIPS_CAPABLE
+	dump_cfg_fmtint(sFIPS, o->fips_mode);
+#endif
 
 	channel_print_adm_permitted_opens();
 }
--- a/servconf.h
+++ b/servconf.h
@@ -171,6 +171,9 @@
 	char   *revoked_keys_file;
 	char   *trusted_user_ca_keys;
 	char   *authorized_principals_file;
+#ifdef OPENSSL_FIPS_CAPABLE
+	int	fips_mode;
+#endif
 }       ServerOptions;
 
 /*
--- a/ssh-agent.c
+++ b/ssh-agent.c
@@ -249,7 +249,7 @@
 	Identity *id;
 	int i, len;
 	Buffer msg;
-	MD5_CTX md;
+	EVP_MD_CTX md;
 	Key *key;
 
 	buffer_init(&msg);
@@ -285,10 +285,14 @@
 		}
 		memset(buf, 0, 32);
 		BN_bn2bin(challenge, buf + 32 - len);
-		MD5_Init(&md);
-		MD5_Update(&md, buf, 32);
-		MD5_Update(&md, session_id, 16);
-		MD5_Final(mdbuf, &md);
+
+		if (EVP_DigestInit(&md, EVP_md5()) <= 0)
+		  goto failure;
+		if (EVP_DigestUpdate(&md, buf, sizeof buf) <= 0)
+		  goto failure;
+		if (EVP_DigestUpdate(&md, session_id, sizeof session_id) <= 0)
+		  goto failure;
+		EVP_DigestFinal(&md, mdbuf, NULL);
 
 		/* Send the response. */
 		buffer_put_char(&msg, SSH_AGENT_RSA_RESPONSE);
--- a/ssh.c
+++ b/ssh.c
@@ -329,6 +329,17 @@
 	    "ACD:F:I:KL:MNO:PR:S:TVw:W:XYy")) != -1) {
 		switch (opt) {
 		case '1':
+#ifdef OPENSSL_FIPS_CAPABLE
+		      /* we need to check that we have selected the right
+		       * SSH protocol for FIPS mode - otherwise it will simply
+		       * not work and the error messages reported will not be
+		       * particularly useful to the user; so if the user
+		       * explicitly requests protocol 1 we need to tell them
+		       * that it isn't acceptable in FIPS mode
+		       */
+			if (FIPS_mode())
+			  fatal("Protocol 1 is not allowed in FIPS mode");
+#endif /* OPENSSL_FIPS_CAPABLE */
 			options.protocol = SSH_PROTO_1;
 			break;
 		case '2':
@@ -721,6 +732,32 @@
 	/* reinit */
 	log_init(argv0, options.log_level, SYSLOG_FACILITY_USER, !use_syslog);
 
+#ifdef OPENSSL_FIPS_CAPABLE
+	/* note: OpenSSL itself uses OPENSSL_FIPS to indicate
+	 *       wanting to run in FIPS mode
+	 */
+	if (options.fips_mode || getenv("OPENSSL_FIPS")) {
+	  if (!FIPS_mode_set(1)) {
+	    /* make sure the error stack is available for some hint as
+	     * to why this operation failed
+	     */
+	    ERR_load_crypto_strings();
+	    ERR_print_errors_fp(stdout);
+	    printf("FIPS_mode_set(): failed to enter FIPS mode!\n");
+	    exit(1);
+	  }
+	  /* we need to check that we have selected the right
+	   * SSH protocol for FIPS mode - otherwise it will simply
+	   * not work and the error messages reported will not be
+	   * particularly useful to the user; so if the user
+	   * explicitly requests protocol 1 we need to tell them
+	   * that it isn't acceptable in FIPS mode
+	   */
+	  if (SSH_PROTO_1 == options.protocol)
+	      fatal("Protocol 1 is not allowed in FIPS mode");
+	}
+#endif /* OPENSSL_FIPS_CAPABLE */
+
 	seed_rng();
 
 	if (options.user == NULL)
@@ -791,6 +828,20 @@
 
 	timeout_ms = options.connection_timeout * 1000;
 
+#ifdef OPENSSL_FIPS_CAPABLE
+	/* after all the configuration files have been processed we
+	 * need to check that we have selected the right SSH protocol
+	 * for FIPS mode - otherwise it will simply not work and the error
+	 * messages reported will not be particularly useful to the user
+	 */
+	if (FIPS_mode()) {
+		options.protocol &= SSH_PROTO_2;
+		if (options.protocol == 0)
+			fatal("Protocol 2 disabled by configuration but required by FIPS mode");
+		logit("FIPS mode initialized");
+	}
+#endif /* OPENSSL_FIPS_CAPABLE */
+
 	/* Open a connection to the remote host. */
 	if (ssh_connect(host, &hostaddr, options.port,
 	    options.address_family, options.connection_attempts, &timeout_ms,
--- a/sshconnect2.c
+++ b/sshconnect2.c
@@ -196,6 +196,12 @@
 		myproposal[PROPOSAL_ENC_ALGS_CTOS] =
 		myproposal[PROPOSAL_ENC_ALGS_STOC] = options.ciphers;
 	}
+#ifdef OPENSSL_FIPS_CAPABLE
+	else if (FIPS_mode()) {
+		myproposal[PROPOSAL_ENC_ALGS_CTOS] =
+		myproposal[PROPOSAL_ENC_ALGS_STOC] = KEX_FIPS_ENCRYPT;
+	}
+#endif /* OPENSSL_FIPS_CAPABLE */
 	myproposal[PROPOSAL_ENC_ALGS_CTOS] =
 	    compat_cipher_proposal(myproposal[PROPOSAL_ENC_ALGS_CTOS]);
 	myproposal[PROPOSAL_ENC_ALGS_STOC] =
@@ -211,6 +217,12 @@
 		myproposal[PROPOSAL_MAC_ALGS_CTOS] =
 		myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;
 	}
+#ifdef OPENSSL_FIPS_CAPABLE
+ 	else if (FIPS_mode()) {
+		myproposal[PROPOSAL_MAC_ALGS_CTOS] =
+		myproposal[PROPOSAL_MAC_ALGS_STOC] = KEX_FIPS_MAC;
+	}
+#endif /* OPENSSL_FIPS_CAPABLE */
 	if (options.hostkeyalgorithms != NULL)
 		myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =
 		    options.hostkeyalgorithms;
--- a/sshd.c
+++ b/sshd.c
@@ -78,6 +78,8 @@
 #include <openssl/rand.h>
 #include "openbsd-compat/openssl-compat.h"
 
+#include <openssl/err.h>
+
 #ifdef HAVE_SECUREWARE
 #include <sys/security.h>
 #include <prot.h>
@@ -423,9 +425,9 @@
 		major = PROTOCOL_MAJOR_1;
 		minor = PROTOCOL_MINOR_1;
 	}
-	snprintf(buf, sizeof buf, "SSH-%d.%d-%.100s%s", major, minor,
+	snprintf(buf, sizeof buf, "SSH-%d.%d-%.100s%s%s", major, minor,
 	    options.debian_banner ? SSH_RELEASE : SSH_RELEASE_MINIMUM,
-	    newline);
+	    FIPS_mode()?"(enabled)":"(capable)", newline);
 	server_version_string = xstrdup(buf);
 
 	/* Send our protocol version identification. */
@@ -1499,6 +1501,7 @@
 		closefrom(REEXEC_DEVCRYPTO_RESERVED_FD);
 
 	OpenSSL_add_all_algorithms();
+	ERR_load_crypto_strings();
 
 	/*
 	 * Force logging to stderr until we have loaded the private host
@@ -1555,11 +1558,29 @@
 	parse_server_config(&options, rexeced_flag ? "rexec" : config_file_name,
 	    &cfg, NULL, NULL, NULL);
 
-	seed_rng();
-
 	/* Fill in default values for those options not explicitly set. */
 	fill_default_server_options(&options);
 
+#ifdef OPENSSL_FIPS_CAPABLE
+	/* note: there should be a command line option to indicate FIPS140
+	 *       mode; however OpenSSL itself uses OPENSSL_FIPS to indicate
+	 *       wanting to run in FIPS mode
+	 */
+	if (options.fips_mode || getenv("OPENSSL_FIPS")) {
+	  if (!FIPS_mode_set(1)) {
+	    /* make sure the error stack is available for some hint as
+	     * to why this operation failed
+	     */
+	    ERR_load_crypto_strings();
+	    ERR_print_errors_fp(stdout);
+	    printf("FIPS_mode_set(): failed to enter FIPS mode!\n");
+	    exit(1);
+	  }
+	}
+#endif /* OPENSSL_FIPS_CAPABLE */
+
+	seed_rng();
+
 	/* challenge-response is implemented via keyboard interactive */
 	if (options.challenge_response_authentication)
 		options.kbd_interactive_authentication = 1;
@@ -1617,6 +1638,12 @@
 		debug("private host key: #%d type %d %s", i, key->type,
 		    key_type(key));
 	}
+#ifdef OPENSSL_FIPS_CAPABLE
+	if ((options.protocol & SSH_PROTO_1) && FIPS_mode()) {
+		logit("Disabling protocol version 1. Not allowed in FIPS mode");
+		options.protocol &= ~SSH_PROTO_1;
+	}
+#endif /* OPENSSL_FIPS_CAPABLE */
 	if ((options.protocol & SSH_PROTO_1) && !sensitive_data.have_ssh1_key) {
 		logit("Disabling protocol version 1. Could not load host key");
 		options.protocol &= ~SSH_PROTO_1;
@@ -1784,6 +1811,12 @@
 	/* Initialize the random number generator. */
 	arc4random_stir();
 
+#ifdef OPENSSL_FIPS_CAPABLE
+	if (FIPS_mode()) {
+		logit("FIPS mode initialized");
+	}
+#endif /* OPENSSL_FIPS_CAPABLE */
+
 	/* Chdir to the root directory so that the current disk can be
 	   unmounted if desired. */
 	chdir("/");
@@ -2370,6 +2403,12 @@
 		myproposal[PROPOSAL_ENC_ALGS_CTOS] =
 		myproposal[PROPOSAL_ENC_ALGS_STOC] = options.ciphers;
 	}
+#ifdef OPENSSL_FIPS_CAPABLE
+	else if (FIPS_mode()) {
+		myproposal[PROPOSAL_ENC_ALGS_CTOS] =
+		myproposal[PROPOSAL_ENC_ALGS_STOC] = KEX_FIPS_ENCRYPT;
+	}
+#endif /* OPENSSL_FIPS_CAPABLE */
 	myproposal[PROPOSAL_ENC_ALGS_CTOS] =
 	    compat_cipher_proposal(myproposal[PROPOSAL_ENC_ALGS_CTOS]);
 	myproposal[PROPOSAL_ENC_ALGS_STOC] =
@@ -2379,6 +2418,12 @@
 		myproposal[PROPOSAL_MAC_ALGS_CTOS] =
 		myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;
 	}
+#ifdef OPENSSL_FIPS_CAPABLE
+	else if (FIPS_mode()) {
+		myproposal[PROPOSAL_MAC_ALGS_CTOS] =
+		myproposal[PROPOSAL_MAC_ALGS_STOC] = KEX_FIPS_MAC;
+	}
+#endif /* OPENSSL_FIPS_CAPABLE */
 	if (options.compression == COMP_NONE) {
 		myproposal[PROPOSAL_COMP_ALGS_CTOS] =
 		myproposal[PROPOSAL_COMP_ALGS_STOC] = "none";
--- a/ssh-dss.c
+++ b/ssh-dss.c
@@ -47,26 +47,48 @@
     const u_char *data, u_int datalen)
 {
 	DSA_SIG *sig;
-	const EVP_MD *evp_md = EVP_sha1();
+	const EVP_MD *evp_md = EVP_dss1();
 	EVP_MD_CTX md;
-	u_char digest[EVP_MAX_MD_SIZE], sigblob[SIGBLOB_LEN];
-	u_int rlen, slen, len, dlen;
+	u_char sigblob[SIGBLOB_LEN];
+	u_int rlen, slen, len;
 	Buffer b;
+	u_char *tsig;
+	const u_char *psig;
+	EVP_PKEY *pkey;
+	int ok;
 
 	if (key == NULL || key->dsa == NULL || (key->type != KEY_DSA &&
 	    key->type != KEY_DSA_CERT && key->type != KEY_DSA_CERT_V00)) {
 		error("ssh_dss_sign: no DSA key");
 		return -1;
 	}
-	EVP_DigestInit(&md, evp_md);
-	EVP_DigestUpdate(&md, data, datalen);
-	EVP_DigestFinal(&md, digest, &dlen);
+	pkey = EVP_PKEY_new();
+	EVP_PKEY_set1_DSA(pkey, key->dsa);
+	slen = EVP_PKEY_size(pkey);
+	tsig = xmalloc(slen);
+
+	EVP_MD_CTX_init(&md);
+	EVP_SignInit_ex(&md, evp_md, NULL);
+	EVP_SignUpdate(&md, data, datalen);
+	ok = EVP_SignFinal(&md, tsig, &len, pkey);
+	EVP_MD_CTX_cleanup(&md);
+	EVP_PKEY_free(pkey);
 
-	sig = DSA_do_sign(digest, dlen, key->dsa);
-	memset(digest, 'd', sizeof(digest));
+	if (ok != 1) {
+		xfree(tsig);
+		error("ssh_dss_sign: sign failed");
+		return -1;
+	}
+
+	psig = tsig;
+
+	/* Output of EVP_SignFinal() is encoded, convert to DSA_SIG */
+	sig = d2i_DSA_SIG(NULL, &psig, len);
+	memset(tsig, 'd', len);
+	xfree(tsig);
 
 	if (sig == NULL) {
-		error("ssh_dss_sign: sign failed");
+		error("ssh_dss_sign: DSA parse failed");
 		return -1;
 	}
 
@@ -110,12 +132,14 @@
     const u_char *data, u_int datalen)
 {
 	DSA_SIG *sig;
-	const EVP_MD *evp_md = EVP_sha1();
+	const EVP_MD *evp_md = EVP_dss1();
 	EVP_MD_CTX md;
-	u_char digest[EVP_MAX_MD_SIZE], *sigblob;
-	u_int len, dlen;
+	u_char *sigblob;
+	u_int len;
 	int rlen, ret;
 	Buffer b;
+        u_char *tsig, *psig;
+	EVP_PKEY *pkey;
 
 	if (key == NULL || key->dsa == NULL || (key->type != KEY_DSA &&
 	    key->type != KEY_DSA_CERT && key->type != KEY_DSA_CERT_V00)) {
@@ -171,15 +195,27 @@
 	memset(sigblob, 0, len);
 	xfree(sigblob);
 
-	/* sha1 the data */
-	EVP_DigestInit(&md, evp_md);
-	EVP_DigestUpdate(&md, data, datalen);
-	EVP_DigestFinal(&md, digest, &dlen);
-
-	ret = DSA_do_verify(digest, dlen, sig, key->dsa);
-	memset(digest, 'd', sizeof(digest));
-
-	DSA_SIG_free(sig);
+        /* Sig is in DSA_SIG structure, convert to encoded buffer */
+        len = i2d_DSA_SIG(sig, NULL);
+        tsig = xmalloc(len);
+        psig = tsig;
+        i2d_DSA_SIG(sig, &psig);
+        DSA_SIG_free(sig);
+
+        pkey = EVP_PKEY_new();
+        EVP_PKEY_set1_DSA(pkey, key->dsa);
+
+        /* now verify signature */
+        EVP_MD_CTX_init(&md);
+        EVP_VerifyInit(&md, evp_md);
+        EVP_VerifyUpdate(&md, data, datalen);
+        ret = EVP_VerifyFinal(&md, tsig, len, pkey);
+        EVP_MD_CTX_cleanup(&md);
+        EVP_PKEY_free(pkey);
+
+        /* Cleanup buffer */
+        memset(tsig, 'd', len);
+        xfree(tsig);
 
 	debug("ssh_dss_verify: signature %s",
 	    ret == 1 ? "correct" : ret == 0 ? "incorrect" : "error");
--- a/ssh-keygen.c
+++ b/ssh-keygen.c
@@ -1935,6 +1935,24 @@
 	extern int optind;
 	extern char *optarg;
 
+#ifdef OPENSSL_FIPS_CAPABLE
+	/* note: there should be a command line option to indicate FIPS140
+	 *       mode; however OpenSSL itself uses OPENSSL_FIPS to indicate
+	 *       wanting to run in FIPS mode
+	 */
+	if (getenv("OPENSSL_FIPS")) {
+	  if (!FIPS_mode_set(1)) {
+	    /* make sure the error stack is available for some hint as
+	     * to why this operation failed
+	     */
+	    ERR_load_crypto_strings();
+	    ERR_print_errors_fp(stdout);
+	    printf("FIPS_mode_set(): failed to enter FIPS mode!\n");
+	    exit(1);
+	  }
+	}
+#endif /* OPENSSL_FIPS_CAPABLE */
+
 	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
 	sanitise_stdfd();
 
--- a/ssh-rsa.c
+++ b/ssh-rsa.c
@@ -42,10 +42,11 @@
 {
 	const EVP_MD *evp_md;
 	EVP_MD_CTX md;
-	u_char digest[EVP_MAX_MD_SIZE], *sig;
-	u_int slen, dlen, len;
+	u_char *sig;
+	u_int slen, len;
 	int ok, nid;
 	Buffer b;
+	EVP_PKEY *pkey;
 
 	if (key == NULL || key->rsa == NULL || (key->type != KEY_RSA &&
 	    key->type != KEY_RSA_CERT && key->type != KEY_RSA_CERT_V00)) {
@@ -57,15 +58,17 @@
 		error("ssh_rsa_sign: EVP_get_digestbynid %d failed", nid);
 		return -1;
 	}
-	EVP_DigestInit(&md, evp_md);
-	EVP_DigestUpdate(&md, data, datalen);
-	EVP_DigestFinal(&md, digest, &dlen);
-
-	slen = RSA_size(key->rsa);
+	pkey = EVP_PKEY_new();
+	EVP_PKEY_set1_RSA(pkey, key->rsa);
+	slen = EVP_PKEY_size(pkey);
 	sig = xmalloc(slen);
 
-	ok = RSA_sign(nid, digest, dlen, sig, &len, key->rsa);
-	memset(digest, 'd', sizeof(digest));
+	EVP_MD_CTX_init(&md);
+	EVP_SignInit_ex(&md, evp_md, NULL);
+	EVP_SignUpdate(&md, data, datalen);
+	ok = EVP_SignFinal(&md, sig, &len, pkey);
+	EVP_MD_CTX_cleanup(&md);
+	EVP_PKEY_free(pkey);
 
 	if (ok != 1) {
 		int ecode = ERR_get_error();
@@ -111,9 +114,10 @@
 	const EVP_MD *evp_md;
 	EVP_MD_CTX md;
 	char *ktype;
-	u_char digest[EVP_MAX_MD_SIZE], *sigblob;
-	u_int len, dlen, modlen;
+	u_char *sigblob;
+	u_int len, modlen;
 	int rlen, ret, nid;
+	EVP_PKEY *pkey;
 
 	if (key == NULL || key->rsa == NULL || (key->type != KEY_RSA &&
 	    key->type != KEY_RSA_CERT && key->type != KEY_RSA_CERT_V00)) {
@@ -164,105 +168,17 @@
 		xfree(sigblob);
 		return -1;
 	}
-	EVP_DigestInit(&md, evp_md);
-	EVP_DigestUpdate(&md, data, datalen);
-	EVP_DigestFinal(&md, digest, &dlen);
+	pkey = EVP_PKEY_new();
+	EVP_PKEY_set1_RSA(pkey, key->rsa);
+	EVP_MD_CTX_init(&md);
+	EVP_VerifyInit_ex(&md, evp_md, NULL);
+	EVP_VerifyUpdate(&md, data, datalen);
+	ret = EVP_VerifyFinal(&md, sigblob, len, pkey);
+	EVP_MD_CTX_cleanup(&md);
+	EVP_PKEY_free(pkey);
 
-	ret = openssh_RSA_verify(nid, digest, dlen, sigblob, len, key->rsa);
-	memset(digest, 'd', sizeof(digest));
 	memset(sigblob, 's', len);
 	xfree(sigblob);
 	debug("ssh_rsa_verify: signature %scorrect", (ret==0) ? "in" : "");
 	return ret;
 }
-
-/*
- * See:
- * http://www.rsasecurity.com/rsalabs/pkcs/pkcs-1/
- * ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1.asn
- */
-/*
- * id-sha1 OBJECT IDENTIFIER ::= { iso(1) identified-organization(3)
- *	oiw(14) secsig(3) algorithms(2) 26 }
- */
-static const u_char id_sha1[] = {
-	0x30, 0x21, /* type Sequence, length 0x21 (33) */
-	0x30, 0x09, /* type Sequence, length 0x09 */
-	0x06, 0x05, /* type OID, length 0x05 */
-	0x2b, 0x0e, 0x03, 0x02, 0x1a, /* id-sha1 OID */
-	0x05, 0x00, /* NULL */
-	0x04, 0x14  /* Octet string, length 0x14 (20), followed by sha1 hash */
-};
-/*
- * id-md5 OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840)
- *	rsadsi(113549) digestAlgorithm(2) 5 }
- */
-static const u_char id_md5[] = {
-	0x30, 0x20, /* type Sequence, length 0x20 (32) */
-	0x30, 0x0c, /* type Sequence, length 0x09 */
-	0x06, 0x08, /* type OID, length 0x05 */
-	0x2a, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x05, /* id-md5 */
-	0x05, 0x00, /* NULL */
-	0x04, 0x10  /* Octet string, length 0x10 (16), followed by md5 hash */
-};
-
-static int
-openssh_RSA_verify(int type, u_char *hash, u_int hashlen,
-    u_char *sigbuf, u_int siglen, RSA *rsa)
-{
-	u_int ret, rsasize, oidlen = 0, hlen = 0;
-	int len, oidmatch, hashmatch;
-	const u_char *oid = NULL;
-	u_char *decrypted = NULL;
-
-	ret = 0;
-	switch (type) {
-	case NID_sha1:
-		oid = id_sha1;
-		oidlen = sizeof(id_sha1);
-		hlen = 20;
-		break;
-	case NID_md5:
-		oid = id_md5;
-		oidlen = sizeof(id_md5);
-		hlen = 16;
-		break;
-	default:
-		goto done;
-	}
-	if (hashlen != hlen) {
-		error("bad hashlen");
-		goto done;
-	}
-	rsasize = RSA_size(rsa);
-	if (siglen == 0 || siglen > rsasize) {
-		error("bad siglen");
-		goto done;
-	}
-	decrypted = xmalloc(rsasize);
-	if ((len = RSA_public_decrypt(siglen, sigbuf, decrypted, rsa,
-	    RSA_PKCS1_PADDING)) < 0) {
-		error("RSA_public_decrypt failed: %s",
-		    ERR_error_string(ERR_get_error(), NULL));
-		goto done;
-	}
-	if (len < 0 || (u_int)len != hlen + oidlen) {
-		error("bad decrypted len: %d != %d + %d", len, hlen, oidlen);
-		goto done;
-	}
-	oidmatch = timingsafe_bcmp(decrypted, oid, oidlen) == 0;
-	hashmatch = timingsafe_bcmp(decrypted + oidlen, hash, hlen) == 0;
-	if (!oidmatch) {
-		error("oid mismatch");
-		goto done;
-	}
-	if (!hashmatch) {
-		error("hash mismatch");
-		goto done;
-	}
-	ret = 1;
-done:
-	if (decrypted)
-		xfree(decrypted);
-	return ret;
-}
--- a/version.h
+++ b/version.h
@@ -3,7 +3,15 @@
 #define SSH_VERSION	"OpenSSH_6.0"
 
 #define SSH_PORTABLE	"p1"
-#define SSH_RELEASE_MINIMUM	SSH_VERSION SSH_PORTABLE
+
+/* it is important to provide an indication that FIPS is supported */
+#ifdef OPENSSL_FIPS_CAPABLE
+#define SSH_FIPS	"-FIPS"
+#else
+#define SSH_FIPS	""
+#endif /* OPENSSL_FIPS_CAPABLE */
+
+#define SSH_RELEASE_MINIMUM	SSH_VERSION SSH_PORTABLE SSH_FIPS
 #ifdef SSH_EXTRAVERSION
 #define SSH_RELEASE	SSH_RELEASE_MINIMUM " " SSH_EXTRAVERSION
 #else
--- a/configure
+++ b/configure
@@ -1,14 +1,12 @@
 #! /bin/sh
 # From configure.ac Revision: 1.489 .
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.68 for OpenSSH Portable.
+# Generated by GNU Autoconf 2.69 for OpenSSH Portable.
 #
 # Report bugs to <openssh-unix-dev@mindrot.org>.
 #
 #
-# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
-# 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software
-# Foundation, Inc.
+# Copyright (C) 1992-1996, 1998-2012 Free Software Foundation, Inc.
 #
 #
 # This configure script is free software; the Free Software Foundation
@@ -137,6 +135,31 @@
 # CDPATH.
 (unset CDPATH) >/dev/null 2>&1 && unset CDPATH
 
+# Use a proper internal environment variable to ensure we don't fall
+  # into an infinite loop, continuously re-executing ourselves.
+  if test x"${_as_can_reexec}" != xno && test "x$CONFIG_SHELL" != x; then
+    _as_can_reexec=no; export _as_can_reexec;
+    # We cannot yet assume a decent shell, so we have to provide a
+# neutralization value for shells without unset; and this also
+# works around shells that cannot unset nonexistent variables.
+# Preserve -v and -x to the replacement shell.
+BASH_ENV=/dev/null
+ENV=/dev/null
+(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+case $- in # ((((
+  *v*x* | *x*v* ) as_opts=-vx ;;
+  *v* ) as_opts=-v ;;
+  *x* ) as_opts=-x ;;
+  * ) as_opts= ;;
+esac
+exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
+# Admittedly, this is quite paranoid, since all the known shells bail
+# out after a failed `exec'.
+$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
+as_fn_exit 255
+  fi
+  # We don't want this to propagate to other subprocesses.
+          { _as_can_reexec=; unset _as_can_reexec;}
 if test "x$CONFIG_SHELL" = x; then
   as_bourne_compatible="if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :
   emulate sh
@@ -170,7 +193,8 @@
 else
   exitcode=1; echo positional parameters were not saved.
 fi
-test x\$exitcode = x0 || exit 1"
+test x\$exitcode = x0 || exit 1
+test -x / || exit 1"
   as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
   as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
   eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
@@ -215,21 +239,25 @@
 
 
       if test "x$CONFIG_SHELL" != x; then :
-  # We cannot yet assume a decent shell, so we have to provide a
-	# neutralization value for shells without unset; and this also
-	# works around shells that cannot unset nonexistent variables.
-	# Preserve -v and -x to the replacement shell.
-	BASH_ENV=/dev/null
-	ENV=/dev/null
-	(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
-	export CONFIG_SHELL
-	case $- in # ((((
-	  *v*x* | *x*v* ) as_opts=-vx ;;
-	  *v* ) as_opts=-v ;;
-	  *x* ) as_opts=-x ;;
-	  * ) as_opts= ;;
-	esac
-	exec "$CONFIG_SHELL" $as_opts "$as_myself" ${1+"$@"}
+  export CONFIG_SHELL
+             # We cannot yet assume a decent shell, so we have to provide a
+# neutralization value for shells without unset; and this also
+# works around shells that cannot unset nonexistent variables.
+# Preserve -v and -x to the replacement shell.
+BASH_ENV=/dev/null
+ENV=/dev/null
+(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+case $- in # ((((
+  *v*x* | *x*v* ) as_opts=-vx ;;
+  *v* ) as_opts=-v ;;
+  *x* ) as_opts=-x ;;
+  * ) as_opts= ;;
+esac
+exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
+# Admittedly, this is quite paranoid, since all the known shells bail
+# out after a failed `exec'.
+$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
+exit 255
 fi
 
     if test x$as_have_required = xno; then :
@@ -332,6 +360,14 @@
 
 
 } # as_fn_mkdir_p
+
+# as_fn_executable_p FILE
+# -----------------------
+# Test if FILE is an executable regular file.
+as_fn_executable_p ()
+{
+  test -f "$1" && test -x "$1"
+} # as_fn_executable_p
 # as_fn_append VAR VALUE
 # ----------------------
 # Append the text in VALUE to the end of the definition contained in VAR. Take
@@ -453,6 +489,10 @@
   chmod +x "$as_me.lineno" ||
     { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
 
+  # If we had to re-execute with $CONFIG_SHELL, we're ensured to have
+  # already done that, so ensure we don't try to do so again and fall
+  # in an infinite loop.  This has already happened in practice.
+  _as_can_reexec=no; export _as_can_reexec
   # Don't try to exec as it changes $[0], causing all sort of problems
   # (the dirname of $[0] is not the place where we might find the
   # original and so on.  Autoconf is especially sensitive to this).
@@ -487,16 +527,16 @@
     # ... but there are two gotchas:
     # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
     # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
-    # In both cases, we have to default to `cp -p'.
+    # In both cases, we have to default to `cp -pR'.
     ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
-      as_ln_s='cp -p'
+      as_ln_s='cp -pR'
   elif ln conf$$.file conf$$ 2>/dev/null; then
     as_ln_s=ln
   else
-    as_ln_s='cp -p'
+    as_ln_s='cp -pR'
   fi
 else
-  as_ln_s='cp -p'
+  as_ln_s='cp -pR'
 fi
 rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
 rmdir conf$$.dir 2>/dev/null
@@ -508,28 +548,8 @@
   as_mkdir_p=false
 fi
 
-if test -x / >/dev/null 2>&1; then
-  as_test_x='test -x'
-else
-  if ls -dL / >/dev/null 2>&1; then
-    as_ls_L_option=L
-  else
-    as_ls_L_option=
-  fi
-  as_test_x='
-    eval sh -c '\''
-      if test -d "$1"; then
-	test -d "$1/.";
-      else
-	case $1 in #(
-	-*)set "./$1";;
-	esac;
-	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
-	???[sx]*):;;*)false;;esac;fi
-    '\'' sh
-  '
-fi
-as_executable_p=$as_test_x
+as_test_x='test -x'
+as_executable_p=as_fn_executable_p
 
 # Sed expression to map a string onto a valid CPP name.
 as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
@@ -726,6 +746,7 @@
 with_libedit
 with_audit
 with_ssl_dir
+with_fips_dir
 with_openssl_header_check
 with_ssl_engine
 with_prngd_port
@@ -1223,8 +1244,6 @@
 if test "x$host_alias" != x; then
   if test "x$build_alias" = x; then
     cross_compiling=maybe
-    $as_echo "$as_me: WARNING: if you wanted to set the --build type, don't use --host.
-    If a cross compiler is detected then cross compile mode will be used" >&2
   elif test "x$build_alias" != "x$host_alias"; then
     cross_compiling=yes
   fi
@@ -1416,6 +1435,7 @@
   --with-libedit[=PATH]   Enable libedit support for sftp
   --with-audit=module     Enable audit support (modules=debug,bsm,linux)
   --with-ssl-dir=PATH     Specify path to OpenSSL installation
+  --with-fips-dir=PATH     Specify path to OpenSSL FIPS installation
   --without-openssl-header-check Disable OpenSSL version consistency check
   --with-ssl-engine       Enable OpenSSL (hardware) ENGINE support
   --with-prngd-port=PORT  read entropy from PRNGD/EGD TCP localhost:PORT
@@ -1516,9 +1536,9 @@
 if $ac_init_version; then
   cat <<\_ACEOF
 OpenSSH configure Portable
-generated by GNU Autoconf 2.68
+generated by GNU Autoconf 2.69
 
-Copyright (C) 2010 Free Software Foundation, Inc.
+Copyright (C) 2012 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 _ACEOF
@@ -1750,7 +1770,7 @@
 	 test ! -s conftest.err
        } && test -s conftest$ac_exeext && {
 	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
+	 test -x conftest$ac_exeext
        }; then :
   ac_retval=0
 else
@@ -1998,7 +2018,8 @@
 main ()
 {
 static int test_array [1 - 2 * !(($2) >= 0)];
-test_array [0] = 0
+test_array [0] = 0;
+return test_array [0];
 
   ;
   return 0;
@@ -2014,7 +2035,8 @@
 main ()
 {
 static int test_array [1 - 2 * !(($2) <= $ac_mid)];
-test_array [0] = 0
+test_array [0] = 0;
+return test_array [0];
 
   ;
   return 0;
@@ -2040,7 +2062,8 @@
 main ()
 {
 static int test_array [1 - 2 * !(($2) < 0)];
-test_array [0] = 0
+test_array [0] = 0;
+return test_array [0];
 
   ;
   return 0;
@@ -2056,7 +2079,8 @@
 main ()
 {
 static int test_array [1 - 2 * !(($2) >= $ac_mid)];
-test_array [0] = 0
+test_array [0] = 0;
+return test_array [0];
 
   ;
   return 0;
@@ -2090,7 +2114,8 @@
 main ()
 {
 static int test_array [1 - 2 * !(($2) <= $ac_mid)];
-test_array [0] = 0
+test_array [0] = 0;
+return test_array [0];
 
   ;
   return 0;
@@ -2220,7 +2245,7 @@
 running configure, to aid debugging if configure makes a mistake.
 
 It was created by OpenSSH $as_me Portable, which was
-generated by GNU Autoconf 2.68.  Invocation command line was
+generated by GNU Autoconf 2.69.  Invocation command line was
 
   $ $0 $@
 
@@ -2600,7 +2625,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="${ac_tool_prefix}gcc"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -2640,7 +2665,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_CC="gcc"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -2693,7 +2718,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="${ac_tool_prefix}cc"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -2734,7 +2759,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
        ac_prog_rejected=yes
        continue
@@ -2792,7 +2817,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -2836,7 +2861,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_CC="$ac_prog"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -3282,8 +3307,7 @@
 /* end confdefs.h.  */
 #include <stdarg.h>
 #include <stdio.h>
-#include <sys/types.h>
-#include <sys/stat.h>
+struct stat;
 /* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
 struct buf { int x; };
 FILE * (*rcsopen) (struct buf *, struct stat *, int);
@@ -3623,7 +3647,7 @@
     for ac_prog in grep ggrep; do
     for ac_exec_ext in '' $ac_executable_extensions; do
       ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_GREP" && $as_test_x "$ac_path_GREP"; } || continue
+      as_fn_executable_p "$ac_path_GREP" || continue
 # Check for GNU ac_path_GREP and select it if it is found.
   # Check for GNU $ac_path_GREP
 case `"$ac_path_GREP" --version 2>&1` in
@@ -3689,7 +3713,7 @@
     for ac_prog in egrep; do
     for ac_exec_ext in '' $ac_executable_extensions; do
       ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_EGREP" && $as_test_x "$ac_path_EGREP"; } || continue
+      as_fn_executable_p "$ac_path_EGREP" || continue
 # Check for GNU ac_path_EGREP and select it if it is found.
   # Check for GNU $ac_path_EGREP
 case `"$ac_path_EGREP" --version 2>&1` in
@@ -4110,7 +4134,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_AWK="$ac_prog"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -4288,7 +4312,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -4328,7 +4352,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_RANLIB="ranlib"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -4400,7 +4424,7 @@
     # by default.
     for ac_prog in ginstall scoinst install; do
       for ac_exec_ext in '' $ac_executable_extensions; do
-	if { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; }; then
+	if as_fn_executable_p "$as_dir/$ac_prog$ac_exec_ext"; then
 	  if test $ac_prog = install &&
 	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
 	    # AIX install.  It has an incompatible calling convention.
@@ -4475,7 +4499,7 @@
     for ac_prog in egrep; do
     for ac_exec_ext in '' $ac_executable_extensions; do
       ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_EGREP" && $as_test_x "$ac_path_EGREP"; } || continue
+      as_fn_executable_p "$ac_path_EGREP" || continue
 # Check for GNU ac_path_EGREP and select it if it is found.
   # Check for GNU $ac_path_EGREP
 case `"$ac_path_EGREP" --version 2>&1` in
@@ -4541,7 +4565,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_AR="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -4581,7 +4605,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_CAT="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -4621,7 +4645,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_KILL="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -4663,7 +4687,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_PERL="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -4706,7 +4730,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_SED="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -4747,7 +4771,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_ENT="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -4788,7 +4812,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_TEST_MINUS_S_SH="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -4828,7 +4852,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_TEST_MINUS_S_SH="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -4868,7 +4892,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_TEST_MINUS_S_SH="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -4908,7 +4932,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_SH="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -4948,7 +4972,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_GROFF="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -4988,7 +5012,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_NROFF="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -5028,7 +5052,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_MANDOC="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -5084,7 +5108,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_PATH_GROUPADD_PROG="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -5125,7 +5149,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_PATH_USERADD_PROG="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -5164,7 +5188,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_MAKE_PACKAGE_SUPPORTED="yes"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -5391,6 +5415,8 @@
 esac
 rm -rf conftest*
   fi
+
+
 fi
 
 
@@ -5425,7 +5451,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_LOGIN_PROGRAM_FALLBACK="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -5473,7 +5499,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_PATH_PASSWD_PROG="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -9171,7 +9197,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_PKGCONFIG="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -9214,7 +9240,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_ac_pt_PKGCONFIG="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -10811,6 +10837,47 @@
 fi
 
 LIBS="-lcrypto $LIBS"
+
+# Check whether --with-fips-dir was given.
+if test "${with_fips_dir+set}" = set; then :
+  withval=$with_fips_dir;
+		if test "x$withval" != "xno" ; then
+			case "$withval" in
+				# Relative paths
+				./*|../*)	withval="`pwd`/$withval"
+			esac
+#			if test -d "$withval/lib"; then
+#				if test -n "${need_dash_r}"; then
+#					LDFLAGS="-L${withval}/lib -R${withval}/lib ${LDFLAGS}"
+#				else
+#					LDFLAGS="-L${withval}/lib -Wl,-R${withval} ${LDFLAGS}"
+#				fi
+#			else
+#				if test -n "${need_dash_r}"; then
+#					LDFLAGS="-L${withval} -R${withval} ${LDFLAGS}"
+#				else
+#					LDFLAGS="-L${withval} -Wl,-R${withval} ${LDFLAGS}"
+#				fi
+#			fi
+#			if test -d "$withval/include"; then
+#				CPPFLAGS="-DOPENSSL_FIPS_CAPABLE -I${withval}/include ${CPPFLAGS}"
+#			else
+#				CPPFLAGS="-DOPENSSL_FIPS_CAPABLE -I${withval} ${CPPFLAGS}"
+#			fi
+			if test -d "$withval"; then
+				CPPFLAGS="-DOPENSSL_FIPS_CAPABLE ${CPPFLAGS}"
+
+$as_echo "#define OPENSSL_FIPS_CAPABLE 1" >>confdefs.h
+
+				fips="yes"
+			fi
+		fi
+		openssl_check_nonfatal=1
+
+
+fi
+
+LIBS="-lcrypto $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
@@ -15057,7 +15124,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_KRB5CONF="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -15588,7 +15655,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_xauth_path="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -15871,7 +15938,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_NROFF="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -17067,16 +17134,16 @@
     # ... but there are two gotchas:
     # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
     # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
-    # In both cases, we have to default to `cp -p'.
+    # In both cases, we have to default to `cp -pR'.
     ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
-      as_ln_s='cp -p'
+      as_ln_s='cp -pR'
   elif ln conf$$.file conf$$ 2>/dev/null; then
     as_ln_s=ln
   else
-    as_ln_s='cp -p'
+    as_ln_s='cp -pR'
   fi
 else
-  as_ln_s='cp -p'
+  as_ln_s='cp -pR'
 fi
 rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
 rmdir conf$$.dir 2>/dev/null
@@ -17136,28 +17203,16 @@
   as_mkdir_p=false
 fi
 
-if test -x / >/dev/null 2>&1; then
-  as_test_x='test -x'
-else
-  if ls -dL / >/dev/null 2>&1; then
-    as_ls_L_option=L
-  else
-    as_ls_L_option=
-  fi
-  as_test_x='
-    eval sh -c '\''
-      if test -d "$1"; then
-	test -d "$1/.";
-      else
-	case $1 in #(
-	-*)set "./$1";;
-	esac;
-	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
-	???[sx]*):;;*)false;;esac;fi
-    '\'' sh
-  '
-fi
-as_executable_p=$as_test_x
+
+# as_fn_executable_p FILE
+# -----------------------
+# Test if FILE is an executable regular file.
+as_fn_executable_p ()
+{
+  test -f "$1" && test -x "$1"
+} # as_fn_executable_p
+as_test_x='test -x'
+as_executable_p=as_fn_executable_p
 
 # Sed expression to map a string onto a valid CPP name.
 as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
@@ -17179,7 +17234,7 @@
 # values after options handling.
 ac_log="
 This file was extended by OpenSSH $as_me Portable, which was
-generated by GNU Autoconf 2.68.  Invocation command line was
+generated by GNU Autoconf 2.69.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
@@ -17241,10 +17296,10 @@
 ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
 ac_cs_version="\\
 OpenSSH config.status Portable
-configured by $0, generated by GNU Autoconf 2.68,
+configured by $0, generated by GNU Autoconf 2.69,
   with options \\"\$ac_cs_config\\"
 
-Copyright (C) 2010 Free Software Foundation, Inc.
+Copyright (C) 2012 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
 
@@ -17334,7 +17389,7 @@
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 if \$ac_cs_recheck; then
-  set X '$SHELL' '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+  set X $SHELL '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
   shift
   \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
   CONFIG_SHELL='$SHELL'
@@ -17971,6 +18026,7 @@
 H=`eval echo ${PRIVSEP_PATH}` ; H=`eval echo ${H}`
 I=`eval echo ${user_path}` ; I=`eval echo ${I}`
 J=`eval echo ${superuser_path}` ; J=`eval echo ${J}`
+K=`eval echo ${fips}` ; J=`eval echo ${K}`
 
 echo ""
 echo "OpenSSH has been configured with the following options:"
@@ -18027,6 +18083,8 @@
 echo "          +for ssh: ${SSHLIBS}"
 fi
 
+echo "                      fips support: $K"
+
 echo ""
 
 if test "x$MAKE_PACKAGE_SUPPORTED" = "xyes" ; then
--- a/key.c
+++ b/key.c
@@ -73,6 +73,11 @@
 
 enum fp_type key_fingerprint_alg(void)
 {
+#ifdef OPENSSL_FIPS_CAPABLE
+  if (FIPS_mode())
+    return SSH_FP_SHA1;
+  else
+#endif /* OPENSSL_FIPS_CAPABLE */
     return SSH_FP_MD5;
 }
 
--- a/authfile.c
+++ b/authfile.c
@@ -147,8 +147,17 @@
 	/* Allocate space for the private part of the key in the buffer. */
 	cp = buffer_append_space(&encrypted, buffer_len(&buffer));
 
-	cipher_set_key_string(&ciphercontext, cipher, passphrase,
-	    CIPHER_ENCRYPT);
+	if (cipher_set_key_string(&ciphercontext, cipher, passphrase,
+					CIPHER_ENCRYPT) < 0) {
+		int ecode = ERR_get_error();
+		error("%s: cipher_set_key_string failed: %s", __FUNCTION__,
+			ERR_error_string(ecode, NULL));
+		/* Destroy temporary data. */
+		memset(buf, 0, sizeof(buf));
+		buffer_free(&buffer);
+		buffer_free(&encrypted);
+		return 0;
+	}
 	cipher_crypt(&ciphercontext, cp,
 	    buffer_ptr(&buffer), buffer_len(&buffer));
 	cipher_cleanup(&ciphercontext);
@@ -471,8 +480,15 @@
 	cp = buffer_append_space(&decrypted, buffer_len(&copy));
 
 	/* Rest of the buffer is encrypted.  Decrypt it using the passphrase. */
-	cipher_set_key_string(&ciphercontext, cipher, passphrase,
-	    CIPHER_DECRYPT);
+	if (cipher_set_key_string(&ciphercontext, cipher, passphrase,
+					CIPHER_DECRYPT) < 0) {
+		int ecode = ERR_get_error();
+		error("%s: cipher_set_key_string failed: %s", __FUNCTION__,
+			ERR_error_string(ecode, NULL));
+		buffer_free(&copy);
+		buffer_free(&decrypted);
+		goto fail;
+	}
 	cipher_crypt(&ciphercontext, cp,
 	    buffer_ptr(&copy), buffer_len(&copy));
 	cipher_cleanup(&ciphercontext);
